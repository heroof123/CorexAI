COREX İÇİN CURSOR MİMARİ ANALİZİ VE AÇIK KAYNAK YAPI TAŞLARI

Bu doküman, konuşma boyunca sorulan sorulara göre Cursor’un özel mimari
özelliklerini, hangi açık kaynak yaklaşımlardan beslendiğini ve Corex
IDE içinde uygulanabilir olan teknik konseptleri özetlemek için
hazırlanmıştır.

  ----------------------------------------------
  1) CURSOR’U ÖZEL YAPAN ANA TEKNİK ÖZELLİKLER
  ----------------------------------------------

1.1 Chat değil Edit Orchestrator Mantığı - Cursor klasik chatbot
değildir. - Chat mesajı → edit planı → diff üretimi → IDE içinde
değişiklik. - AI sadece cevap yazmaz, kodu düzenler.

1.2 Hidden Planning Stage (Gizli Planlama) Pipeline: User input →
internal plan → context seçimi → kod üretimi → diff oluşturma →
kullanıcıya gösterim

1.3 Context Selection Engine Cursor tüm repo’yu modele göndermez.
Seçilen context: - aktif dosya - import edilen dosyalar - ilgili
fonksiyonlar - semantic search sonuçları

Temel konseptler: - RAG (retrieval augmented generation) - code graph

1.4 AST-Aware Editing Kod string olarak değil syntax tree olarak analiz
edilir. Muhtemel açık kaynak: - tree-sitter - babel parser - ts-morph

1.5 Diff-first Generation Yeni dosya yazmak yerine patch üretir.
Kullanılan yaklaşım: - git diff algoritmaları - diff-match-patch

1.6 Streaming Multi-stage Output Sadece token streaming yok: - thinking
phase - content streaming - diff streaming - tool call feedback

  ---------------------------------------------
  2) CURSOR’UN MUHTEMEL AÇIK KAYNAK TEMELLERİ
  ---------------------------------------------

2.1 VS Code Core - Cursor aslında VS Code fork. - Editor engine,
extension sistemi, LSP altyapısı.

2.2 Language Server Protocol (LSP) - Kod semantiğini anlamak. - Jump to
definition vb.

2.3 tree-sitter / AST Parserlar - Syntax-aware edit işlemleri.

2.4 ripgrep - Repo içinde ultra hızlı arama.

2.5 Vector Search Muhtemel: - FAISS - HNSW - embedding tabanlı semantic
search

2.6 Diff algoritmaları - git benzeri patch sistemi.

2.7 Streaming LLM API - token bazlı output.

  -----------------------------------------------------------------
  3) CURSOR’DA OLUP ÇOĞU AI’DA OLMAYAN AMA YAPILABİLİR ÖZELLİKLER
  -----------------------------------------------------------------

-   Semantic Code Graph (import ilişkileri)
-   Smart context auto-selection
-   Edit instead of generate yaklaşımı
-   Hidden planning step
-   Streaming diff UI

  ---------------------------------------------------
  4) COREX İÇİN UYGULANABİLİR CHAT MİMARİSİ (TAURI)
  ---------------------------------------------------

Pipeline:

User Input → Frontend → Tauri Rust backend → LLM Streaming → Event emit
→ Frontend live render

Önemli: - invoke yerine event-based streaming - her token geldiğinde
emit - UI’da tek assistant mesajı sürekli update edilir.

  -------------------------------------------
  5) NEDEN MEVCUT CHAT ROBOTİK HİSSETTİRİR?
  -------------------------------------------

Mevcut durum: User → generate() → full response → UI

Cursor mantığı: User → stream() → incremental UI update

  ------------------------------------
  6) COREX CHAT GELİŞTİRME CHECKLIST
  ------------------------------------

-   streaming event sistemi
-   assistant message live append
-   hidden planning stage
-   context selector
-   diff output mode
-   tool call pipeline

  --------------
  DOKÜMAN SONU
  --------------
